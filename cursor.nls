breed [cursors_breed cursor_breed]
cursors_breed-own 
[
  pulsation-direction 
  pulsation-up-time 
  each-step-up
  pulsation-down-time 
  each-step-down
  
  selected-patch
  selected-patch-original-color
  selected-patch-current-color
  
  distance-from-cube
]


to create-cursor
  cro 1
  [
     set cursor self     
     set breed cursors_breed
     set size 0.8
     set pitch -90
     set shape "arrow"

     set distance-from-cube 0.6
     setxyz 0 pos-border + distance-from-cube pos-border
     set-own-variables
  ]
  
  create-cursor-doppelgaenger
end

to set-own-variables
  set color black
  set pulsation-direction "up"
  set pulsation-up-time 0.2
  set pulsation-down-time 0.6
  
  let frames-up   pulsation-up-time / pause-time
  set each-step-up  4.9 / frames-up
    
  let frames-down pulsation-down-time / pause-time
  set each-step-down 4.9 / frames-down
  
  set selected-patch min-one-of patches with [pbreed = "field"] [ distance cursor ]   
  set selected-patch-original-color [pcolor] of selected-patch
  ask selected-patch
  [
    set pcolor (random 14) * 10  + 3
  ]
end

to create-cursor-doppelgaenger
  cro 1
  [
    set cursor-doppelgaenger self
    set hidden? true 
  ]
end

to pulsate-cursor-color 
  ask cursor
  [
    let selected-color [pcolor] of selected-patch
    let color-string (word selected-color)
    let dot-position 0
    set dot-position position "." color-string
  
    ifelse pulsation-direction = "up"
    [
      ifelse dot-position != false and ((item (dot-position - 1) (word (selected-color + each-step-up))) = "0" or (item (dot-position - 1) (word (selected-color + each-step-up))) = "1")
          
      [
        set selected-color (selected-color + 10)
        set pulsation-direction "down" 
      ]
      [
        set selected-color (selected-color + each-step-up)
      ]
    ] 
    [
       ifelse dot-position != false and item (dot-position - 1) (word (selected-color - each-step-down)) = "2"
       [
         set pulsation-direction "up" 
       ]
       [
         set selected-color (selected-color - each-step-down)
       ]
    ]
    ask selected-patch
    [
      set pcolor selected-color
    ]
  ]
end

to restore-old-pcolor
  set selected-patch-current-color [pcolor] of selected-patch
  let old-pcolor selected-patch-original-color 
  ask selected-patch
  [
    set pcolor old-pcolor
  ]
end

to change-selected-patch
  set selected-patch
  min-one-of patches with [pbreed = "field"] [ distance cursor ]   
  set selected-patch-original-color [pcolor] of selected-patch
  
  let init-color selected-patch-current-color
  ask selected-patch
  [
    set pcolor init-color
  ]
end

to W
  let move-task task [fd 1]
  let wrap-task task [set pitch pitch - 90]
  
  ask cursor
  [
    restore-old-pcolor
    
    let has-to-wrap? false
    if wrap-around-cube? move-task task [zcor > pos-border + [distance-from-cube] of cursor]
    [
      set has-to-wrap? true
      set ycor ycor + distance-from-cube
      set zcor zcor + distance-from-cube
    ]
    
    if wrap-around-cube? move-task task [zcor < neg-border - [distance-from-cube] of cursor]
    [
      set has-to-wrap? true
      set ycor ycor - distance-from-cube
      set zcor zcor - distance-from-cube 
    ]
    
    if wrap-around-cube? move-task task [ycor > pos-border + [distance-from-cube] of cursor]
    [
      set has-to-wrap? true
      set ycor ycor + distance-from-cube
      set zcor zcor - distance-from-cube 
    ]
    
    if wrap-around-cube? move-task task [ycor < neg-border - [distance-from-cube] of cursor]
    [
      set has-to-wrap? true
      set ycor ycor - distance-from-cube
      set zcor zcor + distance-from-cube 
    ] 
    
    ifelse has-to-wrap?
    [
      run wrap-task
    ]
    [
      run move-task  
    ]
    
    change-selected-patch
  ]
end

to A
  if (ycor = pos-border + [distance-from-cube] of cursor) or (ycor = neg-border - [distance-from-cube] of cursor)
  [
    let move-task task [lt 90 fd 1 rt 90]
  ]
  if (xcor = pos-border + [distance-from-cube] of cursor) or (xcor = neg-border - [distance-from-cube] of cursor)
  [
    let move-task task [lt 90 fd 1 rt 90]    
  ]
 let wrap-task task [set roll roll + 90]
  
  ask cursor
  [
    restore-old-pcolor
    
    let has-to-wrap? false
    if wrap-around-cube? move-task task [xcor > pos-border + [distance-from-cube] of cursor]
    [
      set has-to-wrap? true
      set ycor ycor + distance-from-cube
      set xcor xcor + distance-from-cube
    ]
    
    if wrap-around-cube? move-task task [xcor < neg-border - [distance-from-cube] of cursor]
    [
      set has-to-wrap? true
      set ycor ycor - distance-from-cube
      set xcor xcor - distance-from-cube 
    ]
    
    if wrap-around-cube? move-task task [ycor > pos-border + [distance-from-cube] of cursor]
    [
      set has-to-wrap? true
      set ycor ycor + distance-from-cube
      set zcor zcor - distance-from-cube 
    ]
    
    if wrap-around-cube? move-task task [ycor < neg-border - [distance-from-cube] of cursor]
    [
      set has-to-wrap? true
      set ycor ycor - distance-from-cube
      set zcor zcor + distance-from-cube 
    ] 
    
    print has-to-wrap?
    
    ifelse has-to-wrap?
    [
      run wrap-task
    ]
    [
      run move-task  
    ]
    
    change-selected-patch
  ]
end

to-report wrap-around-cube? [move-task condition]
  let report-value false
  ask cursor-doppelgaenger
  [
     set heading [heading] of cursor
     set pitch [pitch] of cursor
     set roll [roll] of cursor
     setxyz [xcor] of cursor [ycor] of cursor [zcor] of cursor
     run move-task
     
     if runresult condition
     [
       set report-value true      
     ]
  ]
  report report-value 
end